{"version":3,"names":[],"mappings":"","sources":["site.js"],"sourcesContent":["/* eslint-env jquery */\n\n// Particle effect for trees to resemble Stranger Things forest view\nconst canvas = document.getElementById('canvas');\nconst context = canvas.getContext('2d');\n\n// Setting up the array for trees\nconst treeArray = [];\nconst dustArray = [];\n\ncanvas.width = window.innerWidth;\ncanvas.height = window.innerHeight;\n\nwindow.addEventListener('resize', () => {\n  canvas.height = window.innerHeight;\n  canvas.width = window.innerWidth;\n});\n\nclass Tree {\n  constructor() {\n    this.width = parseInt(Math.random() * 100 + 10);\n    this.height = canvas.height;\n    this.positionX = parseInt(Math.random() * canvas.width - 200 + 200);\n  }\n}\n\nclass Dust {\n  constructor() {\n    this.width = parseInt(Math.random() * 5 + 1);\n    this.positionX = parseInt(Math.random() * canvas.width * 0.9);\n    this.positionY = parseInt(Math.random() * canvas.height * 0.7);\n    this.opacity = 0;\n  }\n}\n\nconst createObject = (objectArray, ParticleObject, particleMax) => {\n  for (let i = 0; i < particleMax; i += 1) {\n    const particleObject = new ParticleObject();\n    objectArray.push(particleObject);\n  }\n\n  // Sort the array by width so the smaller trees appear in the background :D\n  objectArray.sort((a, b) => a.width - b.width);\n};\n\nconst drawTree = treeObject => {\n  context.beginPath();\n\n  // Base color for the trunk\n  const baseGradient = context.createLinearGradient(\n    treeObject.positionX,\n    0,\n    treeObject.positionX + treeObject.width,\n    2\n  );\n  baseGradient.addColorStop(0.5, 'hsl(204, 80%, 10%)');\n  baseGradient.addColorStop(0.9, 'hsl(204, 95%, 15%)');\n  baseGradient.addColorStop(1, 'hsl(204, 90%, 12.5%)');\n\n  // Check for the inverse and get the absolute value so thinner trees have less saturation\n  const depthOverlay = Math.abs(treeObject.width / 100 - 1).toFixed(2);\n  treeObject.height = parseInt(canvas.height * (treeObject.width / 100) + canvas.height * 0.6);\n\n  // Bottom shadow of tree\n  const overlayGradient = context.createLinearGradient(0, canvas.height, 0, 20);\n  overlayGradient.addColorStop(0.2, 'hsla(204, 80%, 15%, 1)');\n  overlayGradient.addColorStop(0.9, `hsla(204, 10%, ${30 * depthOverlay}%, ${depthOverlay})`);\n\n  context.fillStyle = baseGradient;\n  context.fillRect(treeObject.positionX, 0, treeObject.width, treeObject.height);\n  context.fillStyle = overlayGradient;\n  context.fillRect(treeObject.positionX, 0, treeObject.width, treeObject.height);\n\n  context.closePath();\n  moveTree(treeObject);\n};\n\nconst drawDust = dustObject => {\n  context.save();\n  // Running this before it's draw to determine opacity\n  moveDust(dustObject);\n\n  context.beginPath();\n  context.arc(dustObject.positionX, dustObject.positionY, dustObject.width, 0, 2 * Math.PI);\n  context.fillStyle = `rgba(255, 255, 255, ${dustObject.opacity})`;\n  context.shadowBlur = 10;\n  context.shadowColor = 'white';\n  context.fill();\n\n  context.closePath();\n  context.restore();\n};\n\nconst moveTree = treeObject => {\n  treeObject.positionX += parseInt((treeObject.width / 150) * 3 + 1);\n  if (treeObject.positionX > canvas.width) {\n    treeObject.positionX = 0 - treeObject.width;\n  }\n};\n\nconst moveDust = dustObject => {\n  dustObject.positionX += parseInt((dustObject.width / 4) * 3 + 1);\n  dustObject.positionY += -1;\n\n  if (dustObject.positionX > canvas.width) dustObject.positionX = 0 - dustObject.width;\n  if (0 > dustObject.positionY) {\n    dustObject.positionY = canvas.height - dustObject.width;\n    dustObject.opacity = 0;\n  } else if (0 < dustObject.positionY && 1.0 > dustObject.opacity) {\n    dustObject.opacity += 0.005;\n  }\n};\n\nconst drawStage = () => {\n  context.clearRect(0, 0, canvas.width, canvas.height);\n\n  for (let i = 0, n = dustArray.length, m = 0; i < n; i++) {\n    if (0 == i % 6) {\n      drawTree(treeArray[m]);\n      m++;\n    }\n    drawDust(dustArray[i]);\n  }\n\n  requestAnimationFrame(drawStage);\n};\n\n/* ---------------------------------------------\n  Lights\n  --------------------------------------------- */\n\nconst BulbElement = 1;\nconst BulbDefaultColor = '#A3A2A2';\nlet interval;\nlet index = 0;\nlet selectedText = [];\nlet timeout;\n\nconst BulbColor = {\n  A: '#ffeb04',\n  B: '#e60227',\n  C: '#05a2f1',\n  D: '#70b21d',\n  E: '#ad0073',\n  F: '#00a131',\n  G: '#f5a300',\n  H: '#e75000',\n  I: '#0082ce',\n  J: '#1C48AB',\n  K: '#5C87AA',\n  L: '#E7FFFF',\n  M: '#EECA42',\n  N: '#34CECE',\n  O: '#B7078E',\n  P: '#C9E3E2',\n  Q: '#D3499F',\n  R: '#ECECEA',\n  S: '#E9A321',\n  T: '#F7BF12',\n  U: '#2CA5D0',\n  V: '#C0467F',\n  W: '#0394CB',\n  X: '#FBBD2E',\n  Y: '#E68FD6',\n  Z: '#73BEA9',\n};\n\nfunction reset() {\n  $('#go_for_it')[0].disabled = false;\n  $('#go_for_it').removeClass('send-it');\n  selectedText = [];\n  index = 0;\n  clearInterval(interval);\n}\n\nfunction blink(i) {\n  clearTimeout(timeout);\n  timeout = setTimeout(() => {\n    if (i < selectedText.length) {\n      $(`#b${selectedText[i]}`)[0].children[BulbElement].style.fill = BulbDefaultColor;\n      if (i === selectedText.length - 1) reset();\n    }\n  }, 500);\n}\n\nfunction showLetters() {\n  if (index < selectedText.length) {\n    $(`#b${selectedText[index]}`)[0].children[BulbElement].style.fill =\n      BulbColor[selectedText[index].toUpperCase()];\n    blink(index);\n    if (index !== selectedText.length - 1) index += 1;\n  }\n}\n\nfunction setTextReady() {\n  selectedText = $('#i_text')\n    .val()\n    .split('');\n  if (!$('#go_for_it').selected && 0 < selectedText.length) {\n    interval = setInterval(showLetters, 1000);\n    $('#go_for_it')[0].disabled = true;\n  }\n}\n\n// Sparkles\n\nfunction inputAnimation() {\n  $('#i_text')\n    .focus(function() {\n      $(this)\n        .parent()\n        .addClass('is-focus');\n    })\n    .blur(function() {\n      $(this)\n        .parent()\n        .removeClass('is-focus');\n    });\n\n  $('#i_text').on('blur', () => {\n    $(this)\n      .parent()\n      .removeClass('is-focus is-type');\n  });\n\n  $('#i_text').on('keydown', function(event) {\n    $(this)\n      .parent()\n      .addClass('is-type');\n    if (8 === event.which && '' === $(this).val()) {\n      $(this)\n        .parent()\n        .removeClass('is-type');\n    }\n  });\n}\n\n// Paralax\nfunction parallaxScroll() {\n  const scrolled = $(window).scrollTop();\n  console.log('run');\n  $('#parallax-lvl-0').css('top', `${0 - scrolled * 0.25}px`);\n  $('#parallax-lvl-1').css('top', `${0 - scrolled * 0.5}px`);\n  $('#parallax-lvl-2').css('top', `${0 - scrolled * 0.75}px`);\n  $('#parallax-lvl-3').css('top', `${0 - scrolled * 0.9}px`);\n}\n\n/* ---------------------------------------------\n\t\tHeight 100%\n\t\t--------------------------------------------- */\nfunction jsHeightInit() {\n  (function($) {\n    $('.js-height-full').height($(window).height());\n    $('.js-height-parent').each(function() {\n      $(this).height(\n        $(this)\n          .parent()\n          .first()\n          .height()\n      );\n    });\n  })(jQuery);\n}\n\n$(document).ready(() => {\n  $(window).trigger('resize');\n  $('#go_for_it').on('click', setTextReady);\n  $('#go_for_it').on('click', function() {\n    $(this).addClass('send-it');\n\n    setTimeout(() => {\n      $('#go_for_it').removeClass('send-it');\n    }, 1000);\n  });\n  inputAnimation();\n  createObject(treeArray, Tree, 15);\n  createObject(dustArray, Dust, 90);\n  drawStage();\n});\n\n$(window).resize(() => {\n  jsHeightInit();\n});\n\n$(window).on('scroll', () => {\n  console.log('run');\n  parallaxScroll();\n});\n\nconsole.clear();\n\nclass Grain {\n  constructor(el) {\n    /**\n     * Options\n     * Increase the pattern size if visible pattern\n     */\n    this.patternSize = 200;\n    this.patternScaleX = 1000;\n    this.patternScaleY = 1000;\n    this.patternRefreshInterval = 5;\n    this.patternAlpha = 18;\n\n    /**\n     * Create canvas\n     */\n    this.canvas = el;\n    this.ctx = this.canvas.getContext('2d');\n    this.ctx.scale(this.patternScaleX, this.patternScaleY);\n\n    /**\n     * Create a canvas that will be used to generate grain and used as a\n     * pattern on the main canvas.\n     */\n    this.patternCanvas = document.createElement('canvas');\n    this.patternCanvas.width = this.patternSize;\n    this.patternCanvas.height = this.patternSize;\n    this.patternCtx = this.patternCanvas.getContext('2d');\n    this.patternData = this.patternCtx.createImageData(this.patternSize, this.patternSize);\n    this.patternPixelDataLength = this.patternSize * this.patternSize * 4; // rgba = 4\n\n    /**\n     * Prebind prototype function, so later its easier to user\n     */\n    this.resize = this.resize.bind(this);\n    this.loop = this.loop.bind(this);\n\n    this.frame = 0;\n\n    window.addEventListener('resize', this.resize);\n    this.resize();\n\n    window.requestAnimationFrame(this.loop);\n  }\n\n  resize() {\n    this.canvas.width = window.innerWidth * devicePixelRatio;\n    this.canvas.height = window.innerHeight * devicePixelRatio;\n  }\n\n  update() {\n    const { patternPixelDataLength, patternData, patternAlpha, patternCtx } = this;\n\n    // put a random shade of gray into every pixel of the pattern\n    for (let i = 0; i < patternPixelDataLength; i += 4) {\n      // const value = (Math.random() * 255) | 0;\n      const value = Math.random() * 255;\n\n      patternData.data[i] = value;\n      patternData.data[i + 1] = value;\n      patternData.data[i + 2] = value;\n      patternData.data[i + 3] = patternAlpha;\n    }\n\n    patternCtx.putImageData(patternData, 0, 0);\n  }\n\n  draw() {\n    const { ctx, patternCanvas, canvas, viewHeight } = this;\n    const { width, height } = canvas;\n\n    // clear canvas\n    ctx.clearRect(0, 0, width, height);\n\n    // fill the canvas using the pattern\n    ctx.fillStyle = ctx.createPattern(patternCanvas, 'repeat');\n    ctx.fillRect(0, 0, width, height);\n  }\n\n  loop() {\n    // only update grain every n frames\n    const shouldDraw = 0 === ++this.frame % this.patternRefreshInterval;\n    if (shouldDraw) {\n      this.update();\n      this.draw();\n    }\n\n    window.requestAnimationFrame(this.loop);\n  }\n}\n\n/**\n * Initiate Grain\n */\n\nconst el = document.querySelector('.grain');\nconst grain = new Grain(el);\n(function() {\n  let i;\n\n  const NUM_CONFETTI = 350;\n\n  const COLORS = [[85, 71, 106], [174, 61, 99], [219, 56, 83], [244, 92, 68], [248, 182, 70]];\n\n  const PI_2 = 2 * Math.PI;\n\n  const canvas = document.getElementById('world');\n\n  const context = canvas.getContext('2d');\n\n  window.w = 0;\n\n  window.h = 0;\n\n  const resizeWindow = function() {\n    window.w = canvas.width = window.innerWidth;\n    return (window.h = canvas.height = window.innerHeight);\n  };\n\n  window.addEventListener('resize', resizeWindow, false);\n\n  window.onload = function() {\n    return setTimeout(resizeWindow, 0);\n  };\n\n  const range = function(a, b) {\n    return (b - a) * Math.random() + a;\n  };\n\n  const drawCircle = function(x, y, r, style) {\n    context.beginPath();\n    context.arc(x, y, r, 0, PI_2, false);\n    context.fillStyle = style;\n    return context.fill();\n  };\n\n  let xpos = 0.5;\n\n  document.onmousemove = function(e) {\n    return (xpos = e.pageX / w);\n  };\n\n  window.requestAnimationFrame = (function() {\n    return (\n      window.requestAnimationFrame ||\n      window.webkitRequestAnimationFrame ||\n      window.mozRequestAnimationFrame ||\n      window.oRequestAnimationFrame ||\n      window.msRequestAnimationFrame ||\n      function(callback) {\n        return window.setTimeout(callback, 1000 / 60);\n      }\n    );\n  })();\n\n  const Confetti = (function() {\n    function Confetti() {\n      this.style = COLORS[~~range(0, 5)];\n      this.rgb = `rgba(${this.style[0]},${this.style[1]},${this.style[2]}`;\n      this.r = ~~range(2, 6);\n      this.r2 = 2 * this.r;\n      this.replace();\n    }\n\n    Confetti.prototype.replace = function() {\n      this.opacity = 0;\n      this.dop = 0.03 * range(1, 4);\n      this.x = range(-this.r2, w - this.r2);\n      this.y = range(-20, h - this.r2);\n      this.xmax = w - this.r;\n      this.ymax = h - this.r;\n      this.vx = range(0, 2) + 8 * xpos - 5;\n      return (this.vy = 0.7 * this.r + range(-1, 1));\n    };\n\n    Confetti.prototype.draw = function() {\n      let ref;\n      this.x += this.vx;\n      this.y += this.vy;\n      this.opacity += this.dop;\n      if (1 < this.opacity) {\n        this.opacity = 1;\n        this.dop *= -1;\n      }\n      if (0 > this.opacity || this.y > this.ymax) {\n        this.replace();\n      }\n      if (!(0 < (ref = this.x) && ref < this.xmax)) {\n        this.x = (this.x + this.xmax) % this.xmax;\n      }\n      return drawCircle(~~this.x, ~~this.y, this.r, `${this.rgb},${this.opacity})`);\n    };\n\n    return Confetti;\n  })();\n\n  const confetti = (function() {\n    let j;\n    let ref;\n    const results = [];\n    for (i = j = 1, ref = NUM_CONFETTI; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {\n      results.push(new Confetti());\n    }\n    return results;\n  })();\n\n  window.step = function() {\n    let c;\n    let j;\n    let len;\n\n    requestAnimationFrame(step);\n    context.clearRect(0, 0, w, h);\n    const results = [];\n    for (j = 0, len = confetti.length; j < len; j += 1) {\n      c = confetti[j];\n      results.push(c.draw());\n    }\n    return results;\n  };\n\n  step();\n}.call(this));\n"],"file":"scripts.min.js"}